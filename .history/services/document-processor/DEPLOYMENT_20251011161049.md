# Deployment Guide - Document Processing API

## ðŸ“‹ Table of Contents

1. [Prerequisites](#prerequisites)
2. [Development Deployment](#development-deployment)
3. [Docker Deployment](#docker-deployment)
4. [Kubernetes Deployment](#kubernetes-deployment)
5. [Production Checklist](#production-checklist)
6. [Monitoring](#monitoring)
7. [Troubleshooting](#troubleshooting)

---

## 1. Prerequisites

### System Requirements

**Minimum:**
- CPU: 4 cores
- RAM: 8GB
- Storage: 20GB SSD
- OS: Windows 10+, Ubuntu 20.04+, macOS 11+

**Recommended:**
- CPU: 8+ cores
- RAM: 16GB+
- Storage: 50GB+ SSD
- OS: Ubuntu 22.04 LTS

### Software Dependencies

**Required:**
- Python 3.11+
- Redis 7.0+
- Qdrant 1.7.0+
- Docker 24.0+ (for containerized deployment)
- Kubernetes 1.28+ (for K8s deployment)

**Optional:**
- PostgreSQL 15+ (for persistent job storage)
- Nginx (for reverse proxy)
- Prometheus & Grafana (for monitoring)

---

## 2. Development Deployment

### Step 1: Install Dependencies

```powershell
# Clone repository
git clone <repository-url>
cd "In My Head/services/document-processor"

# Create virtual environment
python -m venv venv
.\venv\Scripts\Activate.ps1

# Install dependencies
pip install -r requirements.txt

# Install additional dev dependencies
pip install pytest pytest-cov locust rich
```

### Step 2: Start Redis

```powershell
# Using Docker
docker run -d -p 6379:6379 --name redis redis:7.0-alpine

# Or using Windows Redis
# Download from: https://github.com/microsoftarchive/redis/releases
redis-server
```

### Step 3: Start Qdrant

```powershell
# Using Docker
docker run -d -p 6333:6333 -p 6334:6334 `
  -v ${PWD}/qdrant_data:/qdrant/storage `
  --name qdrant qdrant/qdrant:v1.7.0
```

### Step 4: Configure Environment

```powershell
# Create .env file
@"
# API Configuration
API_KEYS=dev-key-1,dev-key-2
PORT=8000
HOST=0.0.0.0

# Redis Configuration
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_DB=0

# Qdrant Configuration
QDRANT_HOST=localhost
QDRANT_PORT=6333
QDRANT_COLLECTION=documents

# Rate Limiting
RATE_LIMIT_REQUESTS=100
RATE_LIMIT_WINDOW=60

# CORS
CORS_ORIGINS=*

# Logging
LOG_LEVEL=INFO
"@ | Out-File -FilePath .env -Encoding UTF8
```

### Step 5: Start Celery Workers

```powershell
.\start_celery_workers.ps1
```

### Step 6: Start API Server

```powershell
.\start_api_server.ps1

# Or manually
python -m uvicorn src.app:app --host 0.0.0.0 --port 8000 --reload
```

### Step 7: Verify Deployment

```powershell
# Check health
curl http://localhost:8000/health

# Check API docs
# Open: http://localhost:8000/docs
```

---

## 3. Docker Deployment

### Step 1: Build Docker Image

```dockerfile
# Dockerfile
FROM python:3.11-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    gcc \
    g++ \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application
COPY . .

# Create non-root user
RUN useradd -m -u 1001 appuser && \
    chown -R appuser:appuser /app
USER appuser

# Expose port
EXPOSE 8000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=10s --retries=3 \
  CMD python -c "import requests; requests.get('http://localhost:8000/health')"

# Start server
CMD ["python", "-m", "uvicorn", "src.app:app", "--host", "0.0.0.0", "--port", "8000"]
```

```powershell
# Build image
docker build -t document-processor:latest .

# Run container
docker run -d -p 8000:8000 `
  --name document-processor `
  -e API_KEYS=prod-key-123 `
  -e REDIS_HOST=redis `
  -e QDRANT_HOST=qdrant `
  --network document-net `
  document-processor:latest
```

### Step 2: Docker Compose

```yaml
# docker-compose.yml
version: '3.8'

services:
  redis:
    image: redis:7.0-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 3

  qdrant:
    image: qdrant/qdrant:v1.7.0
    ports:
      - "6333:6333"
      - "6334:6334"
    volumes:
      - qdrant_data:/qdrant/storage
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:6333/health"]
      interval: 10s
      timeout: 3s
      retries: 3

  celery-worker:
    build: .
    command: celery -A src.jobs.celery_app worker --loglevel=info --concurrency=4
    environment:
      - REDIS_HOST=redis
      - QDRANT_HOST=qdrant
      - CELERY_BROKER_URL=redis://redis:6379/1
      - CELERY_RESULT_BACKEND=redis://redis:6379/2
    depends_on:
      - redis
      - qdrant
    volumes:
      - ./temp:/app/temp

  api:
    build: .
    ports:
      - "8000:8000"
    environment:
      - API_KEYS=${API_KEYS}
      - REDIS_HOST=redis
      - QDRANT_HOST=qdrant
      - RATE_LIMIT_REQUESTS=100
      - RATE_LIMIT_WINDOW=60
    depends_on:
      - redis
      - qdrant
      - celery-worker
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 3s
      retries: 3

volumes:
  redis_data:
  qdrant_data:

networks:
  default:
    name: document-net
```

```powershell
# Start all services
docker-compose up -d

# Check status
docker-compose ps

# View logs
docker-compose logs -f api

# Stop services
docker-compose down
```

---

## 4. Kubernetes Deployment

### Step 1: Create Namespace

```yaml
# namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: document-processing
```

```bash
kubectl apply -f namespace.yaml
```

### Step 2: Create Secrets

```yaml
# secrets.yaml
apiVersion: v1
kind: Secret
metadata:
  name: api-secrets
  namespace: document-processing
type: Opaque
stringData:
  api-keys: "prod-key-1,prod-key-2"
```

```bash
kubectl apply -f secrets.yaml
```

### Step 3: Deploy Redis

```yaml
# redis-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis
  namespace: document-processing
spec:
  replicas: 1
  selector:
    matchLabels:
      app: redis
  template:
    metadata:
      labels:
        app: redis
    spec:
      containers:
      - name: redis
        image: redis:7.0-alpine
        ports:
        - containerPort: 6379
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        volumeMounts:
        - name: redis-data
          mountPath: /data
      volumes:
      - name: redis-data
        persistentVolumeClaim:
          claimName: redis-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: redis
  namespace: document-processing
spec:
  selector:
    app: redis
  ports:
  - port: 6379
    targetPort: 6379
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: redis-pvc
  namespace: document-processing
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
```

### Step 4: Deploy Qdrant

```yaml
# qdrant-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: qdrant
  namespace: document-processing
spec:
  replicas: 1
  selector:
    matchLabels:
      app: qdrant
  template:
    metadata:
      labels:
        app: qdrant
    spec:
      containers:
      - name: qdrant
        image: qdrant/qdrant:v1.7.0
        ports:
        - containerPort: 6333
        - containerPort: 6334
        resources:
          requests:
            memory: "1Gi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "1000m"
        volumeMounts:
        - name: qdrant-data
          mountPath: /qdrant/storage
      volumes:
      - name: qdrant-data
        persistentVolumeClaim:
          claimName: qdrant-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: qdrant
  namespace: document-processing
spec:
  selector:
    app: qdrant
  ports:
  - name: http
    port: 6333
    targetPort: 6333
  - name: grpc
    port: 6334
    targetPort: 6334
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: qdrant-pvc
  namespace: document-processing
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 50Gi
```

### Step 5: Deploy API

```yaml
# api-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: document-processor-api
  namespace: document-processing
spec:
  replicas: 3
  selector:
    matchLabels:
      app: document-processor-api
  template:
    metadata:
      labels:
        app: document-processor-api
    spec:
      containers:
      - name: api
        image: your-registry/document-processor:latest
        ports:
        - containerPort: 8000
        env:
        - name: API_KEYS
          valueFrom:
            secretKeyRef:
              name: api-secrets
              key: api-keys
        - name: REDIS_HOST
          value: "redis"
        - name: QDRANT_HOST
          value: "qdrant"
        - name: RATE_LIMIT_REQUESTS
          value: "100"
        - name: RATE_LIMIT_WINDOW
          value: "60"
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 10
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: document-processor-api
  namespace: document-processing
spec:
  selector:
    app: document-processor-api
  ports:
  - port: 80
    targetPort: 8000
  type: LoadBalancer
```

### Step 6: Deploy Celery Workers

```yaml
# celery-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: celery-worker
  namespace: document-processing
spec:
  replicas: 4
  selector:
    matchLabels:
      app: celery-worker
  template:
    metadata:
      labels:
        app: celery-worker
    spec:
      containers:
      - name: worker
        image: your-registry/document-processor:latest
        command: ["celery", "-A", "src.jobs.celery_app", "worker", "--loglevel=info", "--concurrency=4"]
        env:
        - name: REDIS_HOST
          value: "redis"
        - name: QDRANT_HOST
          value: "qdrant"
        - name: CELERY_BROKER_URL
          value: "redis://redis:6379/1"
        - name: CELERY_RESULT_BACKEND
          value: "redis://redis:6379/2"
        resources:
          requests:
            memory: "1Gi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "2000m"
```

### Step 7: Deploy All

```bash
kubectl apply -f redis-deployment.yaml
kubectl apply -f qdrant-deployment.yaml
kubectl apply -f api-deployment.yaml
kubectl apply -f celery-deployment.yaml

# Check status
kubectl get pods -n document-processing
kubectl get services -n document-processing

# Get API endpoint
kubectl get service document-processor-api -n document-processing
```

---

## 5. Production Checklist

### Security

- [ ] API keys generated and stored securely (use secrets manager)
- [ ] TLS/SSL certificates configured (use cert-manager)
- [ ] Firewall rules configured (restrict access to necessary ports)
- [ ] Rate limiting enabled (default: 100 req/min)
- [ ] CORS origins restricted (not using wildcard `*`)
- [ ] Input validation enabled (file size, type, content)
- [ ] No sensitive data in logs
- [ ] Container running as non-root user

### Performance

- [ ] Resource limits configured (CPU, memory)
- [ ] Auto-scaling rules defined (HPA for K8s)
- [ ] Caching enabled (Redis)
- [ ] Database connections pooled
- [ ] Gzip compression enabled
- [ ] CDN configured for static assets (if applicable)

### Reliability

- [ ] Health checks configured (liveness, readiness)
- [ ] Graceful shutdown implemented
- [ ] Circuit breakers configured (for external services)
- [ ] Retry logic with exponential backoff
- [ ] Backup strategy defined (for Redis, Qdrant)
- [ ] Disaster recovery plan documented

### Monitoring

- [ ] Prometheus metrics exposed
- [ ] Grafana dashboards created
- [ ] Alert rules configured
- [ ] Log aggregation setup (ELK or Loki)
- [ ] Error tracking enabled (Sentry)
- [ ] Uptime monitoring configured

### Documentation

- [ ] API documentation published (Swagger UI)
- [ ] Runbooks created (for common issues)
- [ ] Architecture diagrams updated
- [ ] Change log maintained
- [ ] Deployment procedures documented

---

## 6. Monitoring

### Prometheus Metrics

The API exposes metrics at `/metrics` endpoint:

```yaml
# prometheus.yml
scrape_configs:
  - job_name: 'document-processor'
    static_configs:
      - targets: ['document-processor-api:8000']
    metrics_path: '/metrics'
    scrape_interval: 15s
```

**Key Metrics:**
- `http_requests_total` - Total HTTP requests
- `http_request_duration_seconds` - Request duration
- `celery_tasks_total` - Total Celery tasks
- `document_processing_duration_seconds` - Document processing time
- `vector_search_duration_seconds` - Search duration

### Grafana Dashboard

Import dashboard JSON from `monitoring/grafana-dashboard.json`

**Panels:**
- Request rate (req/s)
- Response time (p50, p95, p99)
- Error rate (%)
- Active connections
- Celery queue length
- Document processing throughput

### Alerts

```yaml
# alerts.yml
groups:
  - name: api_alerts
    rules:
      - alert: HighErrorRate
        expr: rate(http_requests_total{status=~"5.."}[5m]) > 0.05
        for: 5m
        annotations:
          summary: "High error rate detected"
      
      - alert: SlowResponseTime
        expr: histogram_quantile(0.95, http_request_duration_seconds) > 1.0
        for: 5m
        annotations:
          summary: "Response time above 1s (p95)"
      
      - alert: ServiceDown
        expr: up{job="document-processor"} == 0
        for: 1m
        annotations:
          summary: "Service is down"
```

---

## 7. Troubleshooting

### Issue: API not starting

**Symptoms:**
- Container exits immediately
- Port already in use

**Solutions:**
```powershell
# Check if port is in use
netstat -ano | findstr :8000

# Kill process
taskkill /PID <pid> /F

# Check logs
docker logs document-processor
```

### Issue: Redis connection failed

**Symptoms:**
- "Cannot connect to Redis" error
- Rate limiting not working

**Solutions:**
```powershell
# Check Redis is running
docker ps | findstr redis

# Test Redis connection
redis-cli ping

# Check Redis logs
docker logs redis
```

### Issue: Qdrant connection failed

**Symptoms:**
- "Cannot connect to Qdrant" error
- Search not working

**Solutions:**
```powershell
# Check Qdrant is running
docker ps | findstr qdrant

# Test Qdrant
curl http://localhost:6333/health

# Check Qdrant logs
docker logs qdrant
```

### Issue: Celery workers not processing

**Symptoms:**
- Jobs stuck in "pending" state
- No workers visible

**Solutions:**
```powershell
# Check Celery workers
celery -A src.jobs.celery_app inspect active

# Restart workers
.\start_celery_workers.ps1

# Check worker logs
Get-Content celery_worker.log -Tail 50
```

### Issue: High memory usage

**Symptoms:**
- Container using >2GB RAM
- OOM kills

**Solutions:**
```yaml
# Reduce worker concurrency
command: ["celery", "-A", "src.jobs.celery_app", "worker", "--concurrency=2"]

# Add memory limits
resources:
  limits:
    memory: "1Gi"

# Enable garbage collection
env:
  - name: PYTHONUNBUFFERED
    value: "1"
```

### Issue: Slow search performance

**Symptoms:**
- Search taking >1s
- High CPU usage

**Solutions:**
```python
# Reduce search limit
search_data = {"query": "...", "limit": 10}  # Instead of 100

# Use Qdrant quantization
# Enable in collection config

# Add caching
# Cache frequent queries in Redis
```

---

## Next Steps

1. **Review security settings** - Ensure all credentials are secure
2. **Configure monitoring** - Set up Prometheus and Grafana
3. **Run load tests** - Use `load_test.py` to verify performance
4. **Document procedures** - Create runbooks for your team
5. **Schedule backups** - Set up automated backups for Redis and Qdrant

For more information, see:
- [API Documentation](PHASE_3_8_COMPLETE.md)
- [Quick Start Guide](QUICKSTART_API.md)
- [Testing Guide](test_e2e.py)
